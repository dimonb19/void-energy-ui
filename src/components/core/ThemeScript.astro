---
/*
  Critical render-path bootloader.
  Inlines void-boot.js and hydrates immediately to prevent FOUC.
  Also injects font preload links for the active theme to eliminate FOUT.
*/

import THEME_REGISTRY from '@config/void-registry.json';
import { STORAGE_KEYS, DOM_ATTRS, DEFAULTS } from '@config/constants';
import { FONT_REGISTRY, USER_FONT_MAP } from '@config/font-registry';

// Import bootloader as a raw string for inline execution.
import bootSource from '@lib/void-boot.js?raw';

// Strip export keywords for inline <script> execution.
// Uses specific pattern to avoid corrupting string literals containing "export".
const cleanBootSource = bootSource.replace(/^export\s+(?=function\s)/gm, '');
---

<script
  is:inline
  set:html={`
    (function() {
      // Inject bootloader (includes resolveTheme, applyTheme, applyPreferences, hydrate).
      ${cleanBootSource}

      // Resolve active theme ID using shared logic (DRY - same as hydrate uses).
      var activeId = resolveTheme('${STORAGE_KEYS.ATMOSPHERE}', ${JSON.stringify(DEFAULTS)});

      // Inject preload tags for active theme fonts (eliminates FOUT).
      var fontRegistry = ${JSON.stringify(FONT_REGISTRY)};
      var fonts = fontRegistry[activeId] || fontRegistry['${DEFAULTS.ATMOSPHERE}'] || [];
      var preloaded = {}; // O(1) lookup for duplicate prevention
      fonts.forEach(function(src) {
        preloaded[src] = true;
        var link = document.createElement('link');
        link.rel = 'preload';
        link.as = 'font';
        link.type = 'font/woff2';
        link.crossOrigin = 'anonymous';
        link.fetchPriority = 'high';
        link.href = src;
        document.head.appendChild(link);
      });

      // Preload user font overrides (eliminates FOUT for custom fonts).
      var userConfig = null;
      try { userConfig = JSON.parse(localStorage.getItem('${STORAGE_KEYS.USER_CONFIG}')); } catch(e) {}

      if (userConfig) {
        var userFontMap = ${JSON.stringify(USER_FONT_MAP)};
        [userConfig.fontHeading, userConfig.fontBody].forEach(function(val) {
          if (!val) return;
          // Extract font-family from "'Font Name', fallback" format
          var match = val.match(/^'([^']+)'/);
          if (match && userFontMap[match[1]]) {
            userFontMap[match[1]].forEach(function(src) {
              // Skip if already preloaded (O(1) lookup)
              if (preloaded[src]) return;
              preloaded[src] = true;
              var link = document.createElement('link');
              link.rel = 'preload';
              link.as = 'font';
              link.type = 'font/woff2';
              link.crossOrigin = 'anonymous';
              link.fetchPriority = 'high';
              link.href = src;
              document.head.appendChild(link);
            });
          }
        });
      }

      // Execute hydration with server-side constants.
      hydrate(
        ${JSON.stringify(THEME_REGISTRY)},
        ${JSON.stringify(STORAGE_KEYS)},
        ${JSON.stringify(DOM_ATTRS)},
        ${JSON.stringify(DEFAULTS)}
      );
    })();
  `}
/>
