/* Physics mixins for surfaces, text effects, and utilities. */

@use 'sass:map';
@use 'engine' as *;
@use 'functions' as *;

// ==========================================================================
// 1. SURFACES
// ==========================================================================

// MIXIN: Floating Surface (Cards, Modals)
// Context: Positive Z-Index. Floats above the void.
// $interactive: boolean - Set to true ONLY if the element is clickable (Link/Button)
@mixin glass-float($interactive: false) {
  // Texture and geometry.
  background: var(--surface-bg);
  border-radius: var(--radius-base);
  border-style: solid;
  border-width: var(--physics-border-width);

  // Lighting.
  border-color: var(--border-color);

  // Shadow switches by physics preset.
  box-shadow: var(--shadow-float);

  // Unified Spring Motion
  // All properties use the same spring for cohesive "object" feel
  transition:
    transform var(--speed-base) var(--ease-spring-gentle),
    border-color var(--speed-base) var(--ease-spring-gentle),
    background-color var(--speed-base) var(--ease-spring-gentle),
    box-shadow var(--speed-base) var(--ease-spring-gentle);

  // Interaction.
  @media (hover: hover) {
    &:hover {
      @if $interactive {
        transform: translateY(var(--lift));
        border-color: var(--energy-primary);
        box-shadow: var(--shadow-lift);
      }
    }
  }
}

// MIXIN: Glass Blur (Backdrop Filter)
// Context: Progressive enhancement for frosted glass effect.
// Note: Falls back gracefully - if not supported, no blur is applied.
@mixin glass-blur {
  @supports (backdrop-filter: blur(1px)) {
    backdrop-filter: blur(var(--physics-blur));
    -webkit-backdrop-filter: blur(var(--physics-blur));
  }
}

// MIXIN: Sunk Surface (Inputs, Sidebars)
// Context: Negative Z-Index. Carved into the void.
@mixin glass-sunk {
  background: var(--bg-sink);

  border: var(--physics-border-width) solid var(--border-color);
  border-radius: var(--radius-base);
  color: var(--text-main);

  // Unified depth.
  box-shadow: var(--shadow-sunk);

  // Unified Spring Transitions
  transition:
    border-color var(--speed-fast) var(--ease-spring-snappy),
    box-shadow var(--speed-fast) var(--ease-spring-snappy),
    outline var(--speed-fast) var(--ease-spring-snappy);

  &:focus-visible {
    border-color: var(--energy-primary);
    box-shadow: var(--focus-ring);
  }
}

// ==========================================================================
// 2. ANIMATIONS
// ==========================================================================

// MIXIN: Atmospheric Shimmer
// Usage: Include in any element that acts as a loading skeleton.
@mixin shimmer {
  background-size: 400% 100%;

  animation: shimmer 3s infinite linear;

  // Default Void gradient.
  background-image: linear-gradient(
    90deg,
    transparent 0%,
    transparent 30%,
    alpha(var(--energy-primary), 15%) 50%,
    transparent 70%,
    transparent 100%
  );

  // Light mode override.
  @include when-light($low-specificity: true) {
    background-image: linear-gradient(
      90deg,
      transparent 0%,
      transparent 30%,
      rgba(255, 255, 255, 0.6) 50%,
      transparent 70%,
      transparent 100%
    );
  }

  // Retro override.
  @include when-retro($low-specificity: true) {
    opacity: 0.5;
    background-image: linear-gradient(
      90deg,
      transparent 0%,
      transparent 43%,
      var(--energy-primary) 43%,
      var(--energy-primary) 47%,
      transparent 47%,
      transparent 100%
    );
  }
}

// Standard Entry Transition (The "Cyber Slide")
// Usage: @include entry-transition;
//
// SPRING PHYSICS: Uses easeSpringGentle for organic entry feel.
// The overshoot creates the "settling into place" effect Apple pioneered.
@mixin entry-transition($duration: var(--speed-base), $delay: 0s) {
  will-change: transform, opacity, filter;
  opacity: 1;
  transform: translateY(0) scale(1);
  filter: blur(0);

  @media (prefers-reduced-motion: no-preference) {
    // Use spring easing for organic feel
    transition:
      opacity $duration var(--ease-spring-gentle) $delay,
      transform $duration var(--ease-spring-gentle) $delay,
      filter $duration var(--ease-spring-gentle) $delay;

    @starting-style {
      opacity: 0;
      transform: translateY(10px) scale(0.98);
      filter: blur(var(--physics-blur));
    }
  }
}

// ==========================================================================
// 4. STATE MANAGEMENT MIXINS (Strict Protocol)
// ==========================================================================
//
// Use data attributes and ARIA states instead of utility classes.
// This ensures state is accessible and visible to CSS selectors.
//
// NAMING CONVENTION: when-state($state) matches when-physics() and when-mode()
//
// Available states:
// - 'active'   : Toggles, Tabs, Selections (aria-pressed, aria-selected, etc.)
// - 'open'     : Dropdowns, Tooltips, Dialogs (data-state="open", [open])
// - 'loading'  : Network operations (aria-busy, data-status="loading")
// - 'disabled' : Non-interactive elements (disabled, aria-disabled)
// - 'error'    : Validation errors (aria-invalid, data-state="error")
//
// ==========================================================================

/// Universal state selector mixin.
///
/// @param {String} $state - State name: 'active', 'open', 'loading', 'disabled', 'error'
/// @content Styles to apply when state is active
///
/// @example scss
///   .btn {
///     @include when-state('active') {
///       background: var(--energy-primary);
///     }
///   }
///
@mixin when-state($state) {
  @if $state == 'active' {
    &[aria-pressed='true'],
    &[aria-selected='true'],
    &[aria-checked='true'],
    &[data-state='active'] {
      @content;
    }
  } @else if $state == 'open' {
    &[data-state='open'],
    &[open] {
      @content;
    }
  } @else if $state == 'loading' {
    &[aria-busy='true'],
    &[data-status='loading'] {
      @content;
    }
  } @else if $state == 'disabled' {
    &:disabled,
    &[aria-disabled='true'],
    &[data-state='disabled'] {
      @content;
    }
  } @else if $state == 'error' {
    &[aria-invalid='true'],
    &[data-state='error'] {
      @content;
    }
  } @else {
    @warn "Unknown state '#{$state}'. Available: active, open, loading, disabled, error";
  }
}

// ==========================================================================
// 5. SCROLLBAR
// ==========================================================================

@mixin laser-scrollbar() {
  scrollbar-width: thin;
  scrollbar-color: var(--energy-secondary) var(--bg-sink);

  &::-webkit-scrollbar {
    width: var(--scrollbar-width);
    height: var(--scrollbar-width);
  }

  &::-webkit-scrollbar-track {
    background: var(--bg-sink);
    border-radius: var(--radius-full);
  }

  &::-webkit-scrollbar-thumb {
    background: var(--energy-secondary);
    border-radius: var(--radius-full);

    &:hover {
      background: var(--energy-primary);
    }
  }
}

// ==========================================================================
// 6. TEXT UTILITIES
// ==========================================================================

// MIXIN: Truncate
// Usage: @include text-truncate(1) for single line
// Usage: @include text-truncate(3) for multi-line narrative
@mixin text-truncate($lines: 1) {
  overflow: hidden;
  text-overflow: ellipsis;

  @if $lines == 1 {
    white-space: nowrap;
  } @else {
    display: -webkit-box;
    -webkit-line-clamp: $lines;
    line-clamp: $lines;
    -webkit-box-orient: vertical;
    white-space: normal;
  }
}

// MIXIN: Force wrap
// Usage: For API keys, hashes, or user-generated "gibberish"
@mixin text-wrap-force {
  overflow-wrap: anywhere;

  word-break: break-word;
}

// ==========================================================================
// 7. RESPONSIVE BREAKPOINTS
// ==========================================================================

@mixin respond-up($breakpoint) {
  @if map.has-key($breakpoints, $breakpoint) {
    @media (min-width: map.get($breakpoints, $breakpoint)) {
      @content;
    }
  } @else {
    @warn "Breakpoint `#{$breakpoint}` not found.";
  }
}

@mixin mobile-only {
  @media (max-width: map.get($breakpoints, 'tablet')) {
    @content;
  }
}

// ==========================================================================
// 8. PHYSICS & MODE OVERRIDES
// ==========================================================================
// Centralized mixins for physics and mode-specific styling.
// Use these instead of raw @at-root [data-physics='...'] & patterns.

/// Apply styles when a specific physics preset is active.
/// @param {String} $physics - The physics preset name ('glass', 'flat', 'retro')
/// @param {Boolean} $low-specificity [false] - Use :where() for lower specificity
/// @content The styles to apply when this physics is active
@mixin when-physics($physics, $low-specificity: false) {
  @if $low-specificity {
    @at-root :where([data-physics='#{$physics}']) & {
      @content;
    }
  } @else {
    @at-root [data-physics='#{$physics}'] & {
      @content;
    }
  }
}

/// Apply styles when a specific mode (light/dark) is active.
/// @param {String} $mode - The mode name ('light', 'dark')
/// @param {Boolean} $low-specificity [false] - Use :where() for lower specificity
/// @content The styles to apply when this mode is active
@mixin when-mode($mode, $low-specificity: false) {
  @if $low-specificity {
    @at-root :where([data-mode='#{$mode}']) & {
      @content;
    }
  } @else {
    @at-root [data-mode='#{$mode}'] & {
      @content;
    }
  }
}

/// Apply styles for a specific physics + mode combination.
/// Use sparingly - most overrides should be physics OR mode, not both.
/// @param {String} $physics - The physics preset name
/// @param {String} $mode - The mode name
/// @content The styles to apply
@mixin when-physics-mode($physics, $mode) {
  @at-root [data-physics='#{$physics}'][data-mode='#{$mode}'] & {
    @content;
  }
}

// ---------------------------------------------------------------------------
// Convenience Aliases
// ---------------------------------------------------------------------------

@mixin when-retro($low-specificity: false) {
  @include when-physics('retro', $low-specificity) {
    @content;
  }
}

@mixin when-glass($low-specificity: false) {
  @include when-physics('glass', $low-specificity) {
    @content;
  }
}

@mixin when-flat($low-specificity: false) {
  @include when-physics('flat', $low-specificity) {
    @content;
  }
}

@mixin when-light($low-specificity: false) {
  @include when-mode('light', $low-specificity) {
    @content;
  }
}

@mixin when-dark($low-specificity: false) {
  @include when-mode('dark', $low-specificity) {
    @content;
  }
}

// ==========================================================================
// 9. BUTTON RESET
// ==========================================================================

/// Naked button reset for unstyled buttons.
/// Removes all default button styling while preserving accessibility.
/// Usage: @include btn-reset;
///
/// @example scss
///   .custom-button {
///     @include btn-reset;
///     // Add custom styles
///   }
///
@mixin btn-reset {
  appearance: none;
  background: transparent;
  border: none;
  padding: 0;
  margin: 0;
  cursor: pointer;
  color: inherit;
  font: inherit;
  min-width: unset;
  min-height: unset;
  display: inline-flex;
}
