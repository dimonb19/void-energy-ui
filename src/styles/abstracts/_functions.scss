/*
 * ROLE: Color helper functions.
 * RESPONSIBILITY: Offer token-friendly tint, shade, fade, and blend operations across native colors and CSS variables.
 */

@use 'sass:color';
@use 'sass:meta';
@use 'sass:math';
@use 'sass:map';
@use 'variables' as *;

// ==========================================================================
// COLOR MIXING STRATEGY
// ==========================================================================
/**
 * All color-mix() operations use OKLCH color space for perceptually
 * uniform blending. This ensures:
 *
 * - Consistent perceived lightness across hue shifts
 * - Smooth gradients without muddy midpoints
 * - Accessibility-friendly contrast preservation
 * - Predictable color interpolation behavior
 *
 * OKLCH (Oklab cylindrical coordinates) provides:
 * - Perceptual uniformity: equal numeric changes = equal visual changes
 * - Hue linearity: mixing colors preserves expected hue progression
 * - Chroma consistency: saturation remains stable during interpolation
 *
 * This is critical for:
 * - Dynamic theming with CSS variables (see tint/shade/alpha/blend functions)
 * - Maintaining WCAG contrast ratios when generating color variants
 * - Ensuring consistent visual weight across different hues
 *
 * Reference: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/oklch
 * Spec: https://www.w3.org/TR/css-color-4/#interpolation-space
 */

// ==========================================================================
// COLOR FUNCTIONS (Polymorphic)
// ==========================================================================

// 1. TINT (Mix with White)
@function tint($color, $percentage) {
  @if meta.type-of($color) == 'color' {
    @return color.mix(white, $color, $percentage);
  } @else {
    @return color-mix(in oklch, $color, white $percentage);
  }
}

// 2. SHADE (Mix with Black)
@function shade($color, $percentage) {
  @if meta.type-of($color) == 'color' {
    @return color.mix(black, $color, $percentage);
  } @else {
    @return color-mix(in oklch, $color, black $percentage);
  }
}

// Internal: normalize opacity input to a percentage value.
@function _normalize-opacity($value) {
  @if meta.type-of($value) == 'number' {
    $percent: if(math.is-unitless($value), $value * 100%, $value);
    // Clamp numeric inputs to 0â€“100%
    @return math.clamp(0%, 100%, $percent);
  }

  // Non-numeric (e.g., var()/calc()) passthrough for CSS mixing
  @return $value;
}

// Internal: compute the complementary transparency term.
@function _opacity-complement($percent) {
  @if meta.type-of($percent) == 'number' {
    @return 100% - $percent;
  }
  @return calc(100% - #{$percent});
}

// 3. ALPHA (Set explicit opacity)
// Usage: alpha(red, 20%) -> 20% opacity (80% transparent)
@function alpha($color, $opacity) {
  $percent: _normalize-opacity($opacity);

  @if meta.type-of($color) == 'color' {
    // Numeric inputs: direct alpha change for Sass colors
    @if meta.type-of($percent) == 'number' {
      $alpha-number: math.div($percent, 100%);
      @return color.change($color, $alpha: $alpha-number);
    }

    // Non-numeric opacity: fall back to color-mix for consistency
    @return color-mix(
      in oklch,
      $color $percent,
      transparent _opacity-complement($percent)
    );
  }

  // CSS variables: mix with transparent using the opacity percentage
  @return color-mix(
    in oklch,
    $color $percent,
    transparent _opacity-complement($percent)
  );
}

// 4. BLEND (Mix Two Colors)
@function blend($color, $other, $other-percentage) {
  @if meta.type-of($color) == 'color' and meta.type-of($other) == 'color' {
    @return color.mix($other, $color, $other-percentage);
  } @else {
    @return color-mix(in oklch, $color, $other $other-percentage);
  }
}

// 5. Z-INDEX FETCH
@function z($layer) {
  @if map.has-key($z-layers, $layer) {
    @return map.get($z-layers, $layer);
  }

  @error "Unknown z-layer '#{$layer}'. Available layers: #{map.keys($z-layers)}";
}
